
The use of robots in undergraduate curricula has grown over the last years. The availability of low cost, easy-to-use platforms has even led to the use of robots in middle and high schools. Many teachers have an interest in introducing robots into their classrooms for teaching a variety of subjects other than specifically robotics. Thus, Educational Robotics arises, proposing the use of robotics as a teaching resource that allows inexperienced students to approach different scientific fields such as mathematics, experimental sciences, technology, information science and computing, among others. One of the aims of Educational Robotics is to aid students in building their own representations and concepts of science and technology, through the use, handling and control of robotic environments. This approach uses the constructionist process of designing, building, programming and debugging robot's behaviours, as well as collaboration and teamwork, as powerful means of enlivening education. 
%***citas del paper de Aibo [2, 6, 7]**** ver bien el afano de citas en este parrafo del primer parrafo de ambos papers.

Several educational robotics programming interfaces have been presented. Most are designed for university-level or late high school students and are implemented as extensions to existing programming languages. That is the case of Pyro \cite{pyro}, a Python-based programming framework which provides a set of abstractions that allow students to write platform-independent robot programs. Other interfaces include Not-Quite C (NQC) \cite{nqc} based on C, BrickOS \cite{brickos} based on C++ and leJOS \cite{lejos} that is based on Java. These three interfaces are particular for Lego Mindstrom. All these interfaces require programming experience or interest in learning a particular programming language. This makes them unsuitable for middle or high school students that do not handle any imperative or procedural programming concepts, such as the idea of loops, conditions, forks or variables in a program. %Educational Robotics courses, which aim at teaching subjects other than robotics or programming. 
Microsoft also offers the commercial tool Microsoft Robotics Developer Studio \cite{mrds}. This includes a visual programming interface based on a data flow approach, but again it requires knowledge of programming concepts, making it quite complex for inexperienced users. 

There are also several graphical environments for simulated robots aimed at middle schools. That is the case of StartLogo \cite{startlogo}, Squeak Etoys \cite{etoys} and Scratch \cite{scratch}. These are easy-to-use programming interfaces, allowing inexperienced students to make a quick start, although they maintain an imperative programming influence and are designed only for particular simulated environments. Another programming interface used in instructional settings at the K-12 level is RoboLab \cite{robolab} for the LEGO Mindstorms robot. This is a graphical environment in which students are given palettes of icons that they can drag and drop on a canvas. The icons represent robot components like motors and sensors, as well as abstract programming structures such as loops and counter variables. This interface is particular for the Mindstrom robot, and once again uses imperative programming structures that add complexity to the robotic environment. Finally, in \cite{robolab-ext} authors present an extension to RoboLab in order to work with other robotic platforms. 

%There are many works describing programming interfaces for Educational Robotics ***citas papers que presenten interfaces ***. Many of them emphasize the proposed applications as didactic tools, easy to learn and use for unexperienced public. To our knowledge, all involve the use of the imperative paradigm in some way for programming robots, . It is not clear if these applications are really easy to use for users that do not handle any imperative or procedural programming concepts, such as the idea of cycles, conditions or forks in a program.

Our experiences working with classroom teachers and young students have raised several issues that have motivated us to pursue the development of a behaviour-based interface, which abstracts away the imperative programming constructs and the low-level motor and sensor commands that often confuse inexperienced programmers or deter techno-phobic students. To accomplish this, we propose to abandon the imperative programming paradigm and take a behaviour-based approach. Thus, the proposed interface is based on a connectionist paradigm. The idea is that stimuli captured by the robot sensors are processed in a network of connections and result in a response for the robot actuators. To program the robot behaviours we have to establish connections between its sensors and actuators. This connections may include different mathematical functions \cite{braitenberg}. Moreover, different defined behaviours can be connected using a subsumption architecture \cite{subsumicion}, making it possible to achieve more complex behaviours. In this way, we get a state automaton (or machine), where each state represents a behaviour and each transition a change in the environment. This state machine can be easily translated into an imperative program that the robot executes to perform the behaviour.

This paper describes the current development of ERBPI(\emph{Easy Robot Behaviour Programming Interface}), a behaviour-based, easy to use robotic programming interface for Educational Robotics that allows to program different robotic platforms and simulators. The design of ERBPI follows the next criteria:

\begin{itemize}
\item \emph{Ease of use:} The user is not supposed to have any previous programming knowledge. The interface must be intuitive and easy to learn, providing all the tools to program robot behaviours graphically, making it possible to perform drag-and-drop with robot's sensors and actuators, build sensor-actuator connections, and easily configure them. 

\item \emph{Platform independence:} The application must work with a variety of robots and simulators, and be easily expandable to control new ones. The different bodies, sensors, actuators, low-level commands and protocols to communicate with high-level systems of different robots must be abstracted. Moreover, users must be able to test and run the same behaviours on multiple robots.

%\item \emph{Expressive power:} The application has to have a computing capacity similar to that provided by programming languages based on the imperative paradigm. This is necessary to perform complex robot behaviours. Our application use a connectionist paradigm to buid basic behaviours and subsumition architecture to build an automaton of state to interconnect them, making possible to achieve more complex behaviours. %(Comentario de Pablo: hasta que no tengamos una demostración formal de que lo que creamos es Turing Compatible no podemos afirmar que tenemos un poder de expresividad equivalente a los programas imperativos. Por eso puse la palabra "similar". Para mi, si en algún momento hacemos esta demostración tenemos un paper para una revista!)
%\item \emph{Comprehensive expressive power:} VER Q PONER ACA - FALTA

%\item \emph{Good for testing and debbuging environment:} PONEMOS ALGO DE LA IDEA DEL DEBUG Y TESTING CON LA WEBCAM? - FALTA (Comentario de Pablo: El problema es que no sabemos si esto realmente se va a poder hacer y no tenemos nada hecho de esto. Yo de la cámara no pondría nada).

\item \emph{Portability:} The application must work in different operating systems and platforms to accommodate the different hardware and software available in schools or other educational institutions.  

\item \emph{Flexibility:} Students from a wide range of backgrounds and teachers with a broad range of goals must be able to use the programming interface effectively, accommodating different levels, curricular needs, academic subjects and physical environments for instruction.

\end{itemize}

This paper is organized as follows. In the next section we describe ERPBI's architecture and features, and give examples of use. Afterward, we comment some experiences using ERPBI in the classroom with high school students. Finally, we draw some conclusions and discuss directions for future work.
